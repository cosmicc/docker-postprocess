#!/usr/bin/env python3

import os
import subprocess
import sys
from configparser import ConfigParser
from pathlib import Path
from time import sleep

from deluge_client import DelugeRPCClient
from loguru import logger as log

__name__ = 'POSTPROC'

os.setgid(int(os.environ['PGID']))
os.setuid(int(os.environ['PUID']))

configfile = "/config/PostProcess.conf"
config = ConfigParser()
config.read(configfile)

loglevel = config.get("general", "loglevel")
logpath = Path(config.get("general", "logpath"))
process_path = Path(config.get("general", "pollpath"))
mp4logpath = Path(config.get("general", "mp4logpath")).mkdir(parents=True, exist_ok=True)
deluge_host = config.get("deluge", "host")
deluge_port = int(config.get("deluge", "port"))
deluge_username = config.get("deluge", "username")
deluge_password = config.get("deluge", "password")

log.remove()
log.level("STARTUP", no=20, color="<fg 39>", icon="¤")
log.level("START", no=20, color="<fg 39>", icon="¤")
log.level("FINISH", no=20, color="<fg 39>", icon="¤")

logformat = "{time:YYYY-MM-DD HH:mm:ss.SSS}|{name: <8}|{level: <7}| {message: <72}"
debuglogformat = "{time:YYYY-MM-DD HH:mm:ss.SSS}|{name}:{line}:{function}|{level: <7}| {message: <72}"

if loglevel == "TRACE":
    lev = 5
    logf = debuglogformat
elif loglevel == "DEBUG":
    lev = 10
    logf = debuglogformat
elif loglevel == "INFO":
    lev = 20
    logf = logformat
elif loglevel == "WARNING":
    lev = 30
    logf = logformat
else:
    lev = 40
    logf = logformat

log.add(sink=str(logpath), level=lev, buffering=1, enqueue=True, backtrace=True, diagnose=True, serialize=False, colorize=False, delay=False, format=logf)
log.add(sys.stderr, level=lev, backtrace=True, diagnose=True, serialize=False, colorize=False, delay=False, format=logf)

comskip_error = ('Success', 'Did not modify original', 'Sanity Check Failed', 'Exception Handled', 'Failed')

if not process_path.exists():
    log.error('Poll directory does not exist!')
    exit(1)

log.log('STARTUP', 'Postprocess main script is starting')

client = DelugeRPCClient(deluge_host, deluge_port, deluge_username, deluge_password)
client.connect()
if client.connected:
    log.debug('Connected to deluge server')
else:
    log.error(f'Cannot connect to deluge server: {deluge_host}:{deluge_port}')


def plexdvrprocess(file):
    fcontents = file.read_text()
    procfull = Path(fcontents.strip())
    procfile = procfull.name
    log.log('START', f'Starting PlexDVR file to process: {str(procfile)}')
    log.debug(f'Process full filepath: {str(procfull)}')
    log.debug(f'Process File: {str(procfile)}')
    procpath = procfull.parent
    log.debug(f'Process File Path: {str(procpath)}')
    log.info(f'Starting commercial skip detection for: {str(procfile)}')
    cmd = ['/opt/PlexComskip.py', f'{str(procfull)}']
    log.debug(f'cmd: {cmd}')
    process = subprocess.Popen(cmd)
    result = process.wait()
    if result != 0 and result != 2 and result != 1 and result != 4:
        log.error(f'Error ({comskip_error[result]}) returned from comskip')
        file.rename(file.with_suffix('.failed'))
    else:
        if result == 0:
            log.success(f'Comskip completed ({comskip_error[result]})')
        else:
            log.warning(f'Comskip completed ({comskip_error[result]})')
        configfile = '/config/autoProcessDVR.ini'
        log.debug(f'Using conversion config file: {configfile}')
        log.info(f'Starting mp4 conversion for: {str(procfile)}')
        cmd = ['/usr/bin/python3', '/opt/mp4_automator/manual.py', '-i', f'{procfull}', '-a', '-c', f'{configfile}']
        log.debug(f'cmd: {cmd}')
        process = subprocess.Popen(cmd)
        result = process.wait()
        if result == 0:
            log.success(f'Conversion returned success')
            file.unlink()
        else:
            log.error(f'Error ({result}) returned in conversion')
            file.rename(file.with_suffix('.failed'))
        log.log('FINISH', f'Finished PlexDVR file proccessing: {str(procfile)}')


def delugeprocess(file):
    fcontents = file.read_text()
    fsplit = fcontents.split('|')
    if len(fsplit) < 4:
        log.warning(f'Cannot parse process file contents ({str(file)})')
        file.rename(file.with_suffix('.ignored'))
    else:
        procfile = Path(fsplit[2])
        log.log('START', f'Starting Deluge file to process: {str(procfile)}')
        log.debug(f'Process File: {str(procfile)}')
        procpath = Path(fsplit[3])
        log.debug(f'Process File Path: {str(procpath)}')
        downloadid = fsplit[1]
        log.debug(f'Deluge Download ID: {downloadid}')
        procfull = procpath / procfile
        log.debug(f'Process full filepath: {str(procfull)}')
        if str(procpath) == '/downloads/complete/tv':
            configfile = '/config/autoProcessTV.ini'
        elif str(procpath) == '/downloads/complete/movies':
            configfile = '/config/autoProcessMOVIE.ini'
        log.debug(f'Using conversion config file: {configfile}')
        log.info(f'Starting mp4 conversion for: {str(procfile)}')
        cmd = ['/usr/bin/python3', '/opt/mp4_automator/manual.py', '-i', f'{procfull}', '-a', '-c', f'{configfile}']
        log.debug(cmd)
        process = subprocess.Popen(cmd)
        result = process.wait()
        if result == 0:
            log.success(f'Conversion returned success')
            file.unlink()
            try:
                client.call('core.remove_torrent', downloadid, True)
            except:
                log.exception(f'Deluge removal for {str(procfile)} failed!')
            else:
                log.info(f'Deluge removal success for {str(procfile)}')
            torrentfile = Path('/downloads/torrents') / (str(procfile) + '.torrent')
            if torrentfile.exists():
                torrentfile.unlink()
                log.info(f'Removed torrent file: {str(torrentfile)}')
            else:
                log.warning(f'No torrent file to remove: {str(torrentfile)}')
        else:
            log.error(f'Error ({result}) returned in conversion')
            file.rename(file.with_suffix('.failed'))
        log.log('FINISH', f'Finished Deluge file proccessing: {str(procfile)}')


while True:
    try:
        # Create the lists of videos to process
        dvrlist = []
        tvlist = []
        movielist = []
        for filep in process_path.iterdir():
            if filep.suffix == '.tvdvr':
                fcontents = filep.read_text()
                if fcontents is None:
                    log.warning(f'Cannot parse process file contents ({str(filep)})')
                    filep.rename(filep.with_suffix('.ignored'))
                else:
                    dvrlist.append(filep)
            elif filep.suffix == '.deluge':
                fcontents = filep.read_text()
                fsplit = fcontents.split('|')
                if len(fsplit) < 4:
                    log.warning(f'Cannot parse process file contents ({str(filep)})')
                    filep.rename(filep.with_suffix('.ignored'))
                else:
                    procpath = Path(fsplit[3])
                    if str(procpath) == '/downloads/complete/tv':
                        tvlist.append(filep)
                    elif str(procpath) == '/downloads/complete/movies':
                        movielist.append(filep)
        if len(dvrlist) > 0 or len(tvlist) > 0 or len(movielist) > 0:
            log.debug(f'Found {len(dvrlist)} tvdvr videos, {len(tvlist)} tv shows, and {len(movielist)} movies to process')
        # Process any tvdvvr videos in the list first
        if len(dvrlist) > 0:
            plexdvrprocess(dvrlist[0])
        # Process any tv shows in the list next
        elif len(tvlist) > 0:
            delugeprocess(tvlist[0])
        # Process any movies in the list last
        elif len(movielist) > 0:
            delugeprocess(movielist[0])
        else:
            sleep(30)
    except:
        log.exception('Error in postrocess main routine:')
        os._exit(1)
